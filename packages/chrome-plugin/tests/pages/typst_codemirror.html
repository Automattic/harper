<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Typst CodeMirror Test</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 2rem;
      }

      .cm-editor {
        border: 1px solid #ccc;
        border-radius: 8px;
        max-width: 640px;
        min-height: 120px;
        padding: 1rem;
      }

      .cm-content {
        min-height: 100px;
        outline: none;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <h1>Typst CodeMirror Regression</h1>
    <div class="cm-editor">
      <div
        id="typst-editor"
        class="cm-content cm-lineWrapping"
        contenteditable="true"
        role="textbox"
        spellcheck="false"
        data-language="typst"
      ></div>
    </div>
    <section id="typst-mirror" style="margin-top: 1rem; font-weight: bold"></section>

    <script type="module">
      const editor = document.getElementById('typst-editor');
      const mirror = document.getElementById('typst-mirror');

      let docText = 'This is an test';
      let isRendering = false;

      const render = () => {
        isRendering = true;
        editor.textContent = docText;
        mirror.textContent = docText;
        isRendering = false;
      };

      const getSelectionOffsets = () => {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return null;

        const range = selection.getRangeAt(0);
        const startRange = document.createRange();
        startRange.selectNodeContents(editor);
        startRange.setEnd(range.startContainer, range.startOffset);

        const endRange = document.createRange();
        endRange.selectNodeContents(editor);
        endRange.setEnd(range.endContainer, range.endOffset);

        return {
          start: startRange.toString().length,
          end: endRange.toString().length,
        };
      };

      const placeCaret = (offset) => {
        const textNode = editor.firstChild;
        if (!textNode || textNode.nodeType !== Node.TEXT_NODE) return;

        const selection = window.getSelection();
        if (!selection) return;

        const clamped = Math.max(0, Math.min(offset, textNode.textContent.length));
        const range = document.createRange();
        range.setStart(textNode, clamped);
        range.setEnd(textNode, clamped);
        selection.removeAllRanges();
        selection.addRange(range);
      };

      const mutationObserver = new MutationObserver(() => {
        if (isRendering) return;

        // Simulate CodeMirror state ownership: direct DOM writes are reverted
        // unless they are expressed as a supported editor transaction.
        if ((editor.textContent ?? '') !== docText) {
          render();
        }
      });

      mutationObserver.observe(editor, {
        childList: true,
        subtree: true,
        characterData: true,
      });

      editor.addEventListener('beforeinput', (event) => {
        if (
          event.isTrusted === false &&
          event.inputType === 'insertReplacementText' &&
          typeof event.data === 'string'
        ) {
          const offsets = getSelectionOffsets();
          if (!offsets) return;

          event.preventDefault();
          docText = docText.slice(0, offsets.start) + event.data + docText.slice(offsets.end);
          render();
          placeCaret(offsets.start + event.data.length);
        }
      });

      editor.addEventListener('input', (event) => {
        if (!event.isTrusted) return;
        docText = editor.textContent ?? '';
        mirror.textContent = docText;
      });

      render();
      editor.focus();
      placeCaret(docText.length);
    </script>
  </body>
</html>

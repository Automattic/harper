use actix_web::{web, HttpResponse, Responder};
use harper_core::{Document, FstDictionary, Dialect, linting::LintGroup, linting::Linter};
use serde::{Deserialize, Serialize};


/// This struct represents the nested "suggestions" object in the JSON output.
#[derive(Serialize)]
pub struct Suggestions {
    /// A list of suggested replacements for the linted text.
    pub recommendation: Vec<String>,
}


/// This struct represents a single lint suggestion in the desired JSON output format.
#[derive(Serialize)]
pub struct FormattedLintOutput {
    /// The starting byte index of the linted text.
    pub start: usize,
    /// The length of the linted text in bytes.
    pub length: usize,
    /// The ending byte index of the linted text.
    pub end: usize,
    /// A key for the paragraph, numbered sequentially starting from 1.
    #[serde(rename = "paragraphKey")]
    pub paragraph_key: String,
    /// The actual text string that was linted.
    pub string: String,
    /// The category or type of the lint (e.g., "Spelling", "Grammar").
    #[serde(rename = "type")]
    pub r#type: String,
    /// A nested object containing the list of suggested replacements.
    pub suggestions: Suggestions,
}


/// This struct represents the incoming JSON request body.
#[derive(Deserialize)]
pub struct LintRequest {
    pub text: String,
}


/// This is the main handler for the `/lint` endpoint.
/// It takes a JSON object with a `text` field, runs the linter,
/// and returns a JSON array of `FormattedLintOutput` objects.
pub async fn lint_text(request: web::Json<LintRequest>) -> impl Responder {
    // Create a new document from the input text.
    let document = Document::new_plain_english_curated(&request.text);
   
    // Create a linter.
    // TODO: Consider making Dialect configurable or detecting it.
    // TODO: FstDictionary::curated() might be expensive to call repeatedly.
    // Consider creating it once and sharing it (e.g., using web::Data).
    let dictionary = FstDictionary::curated();
    let mut linter = LintGroup::new_curated(dictionary, Dialect::American);


    // Get lints from the linter.
    let lints_from_linter = linter.lint(&document);

    // Generate paragraph boundaries. A "paragraph" is defined as a line of text separated by a newline.
    let mut para_boundaries: Vec<(usize, std::ops::Range<usize>)> = Vec::new();
    let mut current_offset = 0;
    // We iterate through lines separated by '\n'. The length of the separator is 1 byte.
    for (i, para_text) in request.text.split('\n').enumerate() {
        let para_len = para_text.len();
        // The range covers the text of the paragraph itself.
        para_boundaries.push((i + 1, current_offset..(current_offset + para_len)));
        // We advance the offset by the paragraph length plus the newline character.
        current_offset += para_len + 1;
    }


    // Convert the lints into our `FormattedLintOutput` format.
    let lint_outputs: Vec<FormattedLintOutput> = lints_from_linter
        .iter()
        .map(|lint| {
            // Extract the original text slice that the lint applies to.
            let linted_string = request.text[lint.span.start..lint.span.end].to_string();

            // Find the paragraph number for the current lint.
            let paragraph_key = para_boundaries
                .iter()
                // Find the paragraph whose byte range contains the start of the lint's span.
                .find(|(_, range)| range.contains(&lint.span.start))
                // If found, convert the paragraph number to a string.
                .map(|(para_num, _)| para_num.to_string())
                // If a lint is not found within any paragraph, provide a default empty string.
                .unwrap_or_else(|| "".to_string());

            FormattedLintOutput {
                start: lint.span.start,
                length: lint.span.end - lint.span.start,
                end: lint.span.end,
                paragraph_key, // Use the dynamically found key.
                string: linted_string,
                r#type: lint.lint_kind.to_string(),
                suggestions: Suggestions {
                    recommendation: lint.suggestions.iter().map(|s| s.to_string()).collect(),
                },
            }
        })
        .collect();


    // Return the lint outputs as a JSON response.
    HttpResponse::Ok().json(lint_outputs)
}